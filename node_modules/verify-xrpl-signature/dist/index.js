"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifySignature = void 0;
const ripple_binary_codec_1 = require("ripple-binary-codec");
const ripple_keypairs_1 = require("ripple-keypairs");
exports.verifySignature = (txBlob, explicitMultiSigner) => {
    let txn;
    let signedBy = '';
    let signatureValid = false;
    try {
        txn = ripple_binary_codec_1.decode(txBlob);
    }
    catch (e) {
        throw new Error(`Could not decode the transaction blob (HEX) (${e.message})`);
    }
    const signatureMultiSign = typeof txn.Signers !== 'undefined'
        && Array.isArray(txn.Signers)
        && txn.Signers.length > 0
        && typeof txn.SigningPubKey === 'string'
        && txn.SigningPubKey === '';
    try {
        if (signatureMultiSign && explicitMultiSigner && explicitMultiSigner.match(/^r/)) {
            signedBy = explicitMultiSigner;
        }
        else if (signatureMultiSign && explicitMultiSigner) {
            signedBy = ripple_keypairs_1.deriveAddress(explicitMultiSigner);
        }
        else {
            let signer = txn.SigningPubKey;
            if (signatureMultiSign && txn.Signers && txn.Signers.length > 0) {
                const firstSigner = Object.values(txn.Signers)[0];
                signer = firstSigner.Signer.SigningPubKey;
            }
            signedBy = ripple_keypairs_1.deriveAddress(signer);
        }
    }
    catch (e) {
        throw new Error(`Could not derive an XRPL account address from the transaction (Signing Public Key) (${e.message})`);
    }
    try {
        if (signatureMultiSign && txn.Signers) {
            const matchingSigners = Object.values(txn.Signers).filter((signer) => {
                return ripple_keypairs_1.deriveAddress(signer.Signer.SigningPubKey) === signedBy;
            });
            if (matchingSigners.length > 0) {
                const multiSigner = matchingSigners[0];
                signatureValid = ripple_keypairs_1.verify(ripple_binary_codec_1.encodeForMultisigning(txn, signedBy), multiSigner.Signer.TxnSignature, multiSigner.Signer.SigningPubKey);
            }
            else {
                throw new Error('Explicit MultiSigner not in Signers');
            }
        }
        else {
            signatureValid = ripple_keypairs_1.verify(ripple_binary_codec_1.encodeForSigning(txn), txn.TxnSignature, txn.SigningPubKey);
        }
    }
    catch (e) {
        throw new Error(`Could not encode or verify the transaction (${e.message})`);
    }
    return {
        signedBy,
        signatureValid,
        signatureMultiSign
    };
};
