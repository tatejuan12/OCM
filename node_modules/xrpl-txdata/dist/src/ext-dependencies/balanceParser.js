"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseBalanceChanges = void 0;
const bignumber_js_1 = require("bignumber.js");
const utils_1 = require("./utils");
const lodash_1 = require("lodash");
const groupByAddress = (balanceChanges) => {
    const grouped = lodash_1.groupBy(balanceChanges, node => {
        return node.address;
    });
    return lodash_1.mapValues(grouped, group => {
        return lodash_1.map(group, node => {
            return node.balance;
        });
    });
};
const parseValue = (value) => {
    const v = typeof value !== 'string' && typeof value !== 'number'
        ? (typeof value === 'object' && value ? value.value : value)
        : value;
    return new bignumber_js_1.BigNumber(v);
};
const parseXRPQuantity = (node, valueParser) => {
    const value = valueParser(node);
    if (value === null) {
        return null;
    }
    return {
        address: node.finalFields.Account || node.newFields.Account,
        balance: {
            counterparty: '',
            currency: 'XRP',
            value: utils_1.dropsToXRP(value).toString()
        }
    };
};
const flipTrustlinePerspective = (quantity) => {
    const negatedBalance = (new bignumber_js_1.BigNumber(quantity.balance.value)).negated();
    return {
        address: quantity.balance.counterparty,
        balance: {
            counterparty: quantity.address,
            currency: quantity.balance.currency,
            value: negatedBalance.toString()
        }
    };
};
const parseTrustlineQuantity = (node, valueParser) => {
    const value = valueParser(node);
    if (value === null) {
        return null;
    }
    const fields = lodash_1.isEmpty(node.newFields) ? node.finalFields : node.newFields;
    const result = {
        address: fields.LowLimit.issuer,
        balance: {
            counterparty: fields.HighLimit.issuer,
            currency: fields.Balance.currency,
            value: value.toString()
        }
    };
    return [result, flipTrustlinePerspective(result)];
};
const parseQuantities = (metadata, valueParser) => {
    const values = utils_1.normalizeNodes(metadata).map((node) => {
        if (node.entryType === 'AccountRoot') {
            return [parseXRPQuantity(node, valueParser)];
        }
        else if (node.entryType === 'RippleState') {
            return parseTrustlineQuantity(node, valueParser);
        }
        return [];
    });
    return groupByAddress(lodash_1.compact(lodash_1.flatten(values)));
};
exports.parseBalanceChanges = (metadata) => {
    const quantities = parseQuantities(metadata, (node) => {
        let value = null;
        if (node.newFields.Balance) {
            value = parseValue(node.newFields.Balance);
        }
        else if (node.previousFields.Balance && node.finalFields.Balance) {
            value = parseValue(node.finalFields.Balance).minus(parseValue(node.previousFields.Balance));
        }
        return value === null ? null : value.isZero() ? null : value;
    });
    const formatted = Object.keys(quantities).reduce((a, b) => {
        const formattedQuantities = quantities[b].map(q => {
            return Object.assign(q, {
                formatted: {
                    value: q.counterparty !== '' && q.value.match(/e/)
                        ? String(utils_1.xrplValueToNft(q.value))
                        : q.value,
                    currency: q.currency === 'XRP' && q.counterparty === ''
                        ? 'XRP'
                        : utils_1.currencyCodeFormat(q.currency)
                }
            });
        });
        Object.assign(a, { [b]: formattedQuantities });
        return a;
    }, {});
    // console.dir(formatted, {depth: 40})
    return formatted;
};
