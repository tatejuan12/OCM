"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TxData = exports.utils = void 0;
const websocket_1 = require("websocket");
const debug_1 = require("debug");
const os_1 = require("os");
const events_1 = require("events");
const balanceParser_1 = require("./ext-dependencies/balanceParser");
const log = debug_1.debug('txdata');
const logConnect = log.extend('connect');
const logConnErr = log.extend('connect:error');
const logResolve = log.extend('resolve');
const logInvalid = log.extend('invalid');
var balanceParser_2 = require("./ext-dependencies/balanceParser");
Object.defineProperty(exports, "parseBalanceChanges", { enumerable: true, get: function () { return balanceParser_2.parseBalanceChanges; } });
const utils_1 = require("./ext-dependencies/utils");
exports.utils = { currencyCodeFormat: utils_1.currencyCodeFormat, xrplValueToNft: utils_1.xrplValueToNft, nftValuetoXrpl: utils_1.nftValuetoXrpl };
class TxData {
    constructor(endpoints, options) {
        this.Ended = false;
        this.WsConnections = [];
        this.ReadyConnections = [];
        this.CommandId = 0;
        this.Endpoints = [
            'wss://xrplcluster.com',
            'wss://xrpl.link',
            'wss://s2.ripple.com'
        ];
        this.ConnectionAndQueryTimeoutMs = 1250;
        this.LookupTimeoutMs = 10000;
        this.AllowNoFullHistory = false;
        this.EventBus = new events_1.EventEmitter();
        log('Constructed');
        this.ParseEndpoints(endpoints);
        this.ParseOptions(options);
        return this;
    }
    /**
     * Constructor helpers
     */
    ParseEndpoints(endpoints) {
        if (typeof endpoints !== 'undefined' && Array.isArray(endpoints) && endpoints.length > 0) {
            const alternativeEndpoints = endpoints
                .map(r => {
                return r.trim().replace(/^http/, 'ws');
            })
                .filter(r => {
                return r.match(/^ws[s]{0,1}:\/\//);
            });
            if (alternativeEndpoints.length > 0) {
                this.Endpoints = alternativeEndpoints;
            }
            else {
                throw this.GenerateError('ENDPOINTS_INVALID');
            }
        }
        log('Endpoints', this.Endpoints);
    }
    ParseOptions(options) {
        if (typeof options === 'object' && options !== null) {
            if (typeof options.EndpointTimeoutMs === 'number' && options.EndpointTimeoutMs >= 1) {
                this.ConnectionAndQueryTimeoutMs = options.EndpointTimeoutMs;
            }
            if (typeof options.OverallTimeoutMs === 'number' && options.OverallTimeoutMs >= 1) {
                this.LookupTimeoutMs = options.OverallTimeoutMs;
            }
            if (typeof options.AllowNoFullHistory === 'boolean') {
                this.AllowNoFullHistory = options.AllowNoFullHistory;
            }
        }
        const minTimeoutMs = this.ConnectionAndQueryTimeoutMs * (this.Endpoints.length + 1);
        if (this.LookupTimeoutMs < minTimeoutMs) {
            this.LookupTimeoutMs = minTimeoutMs;
            logInvalid('Overall timeout updated to min. endpoint * perEndpointTO seconds:', this.LookupTimeoutMs / 1000);
        }
    }
    /**
     * PUBLIC
     */
    end() {
        if (!this.Ended) {
            this.Ended = true;
            log('Ending!');
            this.WsConnections.forEach(c => {
                c.close();
            });
            this.Endpoints = [];
            this.ReadyConnections = [];
            this.WsConnections = [];
        }
    }
    getOne(TxHash, WaitForSeconds = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield this.get(TxHash, WaitForSeconds);
            this.end();
            return tx;
        });
    }
    get(TxHash, WaitForSeconds = 0) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.Ended) {
                throw this.GenerateError('OBJECT_IN_ENDED_STATE');
            }
            const meta = {
                attempts: 0,
                connections: 0,
                resolved: false
            };
            const getPromise = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                var e_1, _a;
                let Timer;
                let WaitMode = false;
                let WaitModeFinish;
                const setTimer = (SecondsAdded = 0) => {
                    clearTimeout(Timer);
                    const timeoutMs = this.LookupTimeoutMs + SecondsAdded * 1000;
                    log('Set Timeout Timer at (sec)', timeoutMs / 1000);
                    const TimedOut = () => {
                        if (WaitMode) {
                            WaitModeFinish();
                        }
                        else {
                            reject(this.GenerateError('MAX_LOOKUP_TIME_REACHED'));
                        }
                    };
                    Timer = setTimeout(() => {
                        TimedOut();
                    }, timeoutMs);
                };
                setTimer();
                const cleanup = () => {
                    clearTimeout(Timer);
                    meta.resolved = true;
                    this.EventBus.removeListener('result', onTx);
                    this.EventBus.listeners('tx.' + TxHash).forEach(l => this.EventBus.removeListener('tx.' + TxHash, l));
                };
                const ResolveFormatted = (eventResult, resolvedBy, host) => {
                    var _a;
                    const finish = (customEventResult, customHost) => {
                        var _a, _b, _c, _d, _e;
                        cleanup();
                        const result = this.FormatResult(customEventResult ? customEventResult : eventResult);
                        const balanceChanges = typeof result.meta !== 'undefined'
                            ? balanceParser_1.parseBalanceChanges(result.meta)
                            : {};
                        resolve({
                            result: (customEventResult === null || customEventResult === void 0 ? void 0 : customEventResult.result) ? Object.assign(Object.assign({}, (_a = customEventResult.result) === null || _a === void 0 ? void 0 : _a.transaction), { meta: (_b = customEventResult.result) === null || _b === void 0 ? void 0 : _b.meta, validated: (_c = customEventResult.result) === null || _c === void 0 ? void 0 : _c.validated, ledger_index: (_d = customEventResult.result) === null || _d === void 0 ? void 0 : _d.ledger_index, inLedger: (_e = customEventResult.result) === null || _e === void 0 ? void 0 : _e.ledger_index }) : result,
                            resolvedBy: customHost ? 'asynchash' : resolvedBy,
                            host: customHost ? customHost : host,
                            balanceChanges
                        });
                    };
                    if (((_a = eventResult) === null || _a === void 0 ? void 0 : _a.error) === 'txnNotFound' && WaitForSeconds > 0) {
                        // Not found
                        if (!WaitMode) {
                            log('TX not found on ledger, could still arrive, wait for # sec.:', WaitForSeconds, TxHash);
                            setTimer(WaitForSeconds);
                            WaitMode = true;
                            WaitModeFinish = finish;
                            this.EventBus.once('tx.' + TxHash, event => {
                                finish({
                                    status: event.response.status,
                                    type: event.response.type,
                                    result: event.response
                                }, event.url);
                            });
                        }
                    }
                    else {
                        finish();
                    }
                };
                const onTx = (r) => {
                    if (!meta.resolved && r.txHash === TxHash) {
                        this.EventBus.off('result', onTx);
                        ResolveFormatted(r.result, 'emitter', r.host);
                    }
                };
                this.EventBus.on('result', onTx);
                try {
                    for (var _b = __asyncValues(this.ConnectAndQuery(TxHash)), _c; _c = yield _b.next(), !_c.done;) {
                        const val = _c.value;
                        if (meta.resolved) {
                            break;
                        }
                        meta.attempts++;
                        meta.connections++;
                        if (typeof val.socket !== 'boolean') {
                            if (!meta.resolved && val.socket.readyState === val.socket.OPEN && typeof val.result !== 'boolean') {
                                ResolveFormatted(val.result, 'generator', val.socket.url);
                                break;
                            }
                        }
                        else {
                            // URL is empty if endpoint is defunct (unreachable / not sane (non-FH))
                            if (val.url !== '') {
                                logResolve(`reason @ ${val.url} =`, String(val === null || val === void 0 ? void 0 : val.resolveReason).toUpperCase());
                            }
                            else {
                                // Don't count defunct endpoints in attempt counter
                                meta.attempts--;
                            }
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) yield _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                log(`Getting ${TxHash} done, attempts =`, meta.attempts);
                const allClosedOrClosing = this.WsConnections.filter(c => {
                    return c.readyState === c.CLOSED || c.readyState === c.CLOSING;
                }).length === this.Endpoints.length;
                if (!meta.resolved && meta.connections === this.Endpoints.length && allClosedOrClosing) {
                    // log({reject: true, meta, allClosedOrClosing})
                    reject(this.GenerateError('ALL_CONNECTIONS_FAILED'));
                }
            }));
            return getPromise;
        });
    }
    /**
     * PRIVATE
     */
    FormatResult(result) {
        delete result.id;
        if (typeof result.result !== 'undefined') {
            return result.result;
        }
        return result;
    }
    GenerateError(code) {
        let msg;
        switch (code) {
            case 'OBJECT_IN_ENDED_STATE':
                msg = 'TxData object ended (.getOne() / .end() called)';
                break;
            case 'ENDPOINTS_INVALID':
                msg = 'All endpoints are invalid';
                break;
            case 'ALL_CONNECTIONS_FAILED':
                msg = `All endpoints are offline (or don't provide full history)`;
                break;
            case 'MAX_LOOKUP_TIME_REACHED':
                msg = `Max. lookup time (for all endpoints) reached without receiving a valid response`;
                break;
            default:
                msg = 'Unknown exception';
        }
        const e = new Error(msg);
        e.name = code;
        return e;
    }
    Connect(index = 0) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof this.ReadyConnections[index] === 'undefined' && this.Endpoints[index] !== '') {
                logConnect(this.Endpoints[index]);
                const headers = typeof process === 'object'
                    ? { 'User-Agent': 'XrplTxData/' + os_1.hostname() }
                    : undefined;
                const socket = typeof ((_a = global) === null || _a === void 0 ? void 0 : _a.MockedWebSocket) !== 'undefined' && typeof jest !== 'undefined'
                    ? new ((_b = global) === null || _b === void 0 ? void 0 : _b.MockedWebSocket)('ws://txdata.local')
                    : new websocket_1.w3cwebsocket(this.Endpoints[index], undefined, // Protocols
                    undefined, // Origin
                    headers // Http Headers
                    );
                this.WsConnections[index] = socket;
                const socketMeta = {
                    ready: false
                };
                this.ReadyConnections[index] = new Promise(resolve => {
                    socket.onopen = () => {
                        if (socket.readyState === socket.OPEN) {
                            socket.send(JSON.stringify({ command: 'server_info' }));
                            socket.send(JSON.stringify({ command: 'subscribe', streams: ['transactions'] }));
                        }
                    };
                    // socket.onclose = () => {}
                    socket.onerror = e => {
                        if (!this.Ended) {
                            logConnErr({
                                url: socket.url,
                                type: e === null || e === void 0 ? void 0 : e.name,
                                message: e === null || e === void 0 ? void 0 : e.message,
                                error: e === null || e === void 0 ? void 0 : e.stack
                            });
                            this.Endpoints[index] = '';
                        }
                        resolve(socket);
                    };
                    socket.onmessage = (m) => __awaiter(this, void 0, void 0, function* () {
                        var _a, _b, _c, _d, _e, _f, _g;
                        try {
                            const response = JSON.parse(m.data.toString());
                            if (socketMeta.ready) {
                                this.EventBus.emit('xrpljson', response);
                                const txHash = (_b = (_a = response) === null || _a === void 0 ? void 0 : _a.transaction) === null || _b === void 0 ? void 0 : _b.hash;
                                if (((_c = response) === null || _c === void 0 ? void 0 : _c.validated) && txHash) {
                                    // log('Seen TX', txHash, 'emitted', 'tx.#')
                                    this.EventBus.emit('tx.' + txHash, { response, url: socket.url });
                                }
                            }
                            else {
                                if (typeof ((_e = (_d = response === null || response === void 0 ? void 0 : response.result) === null || _d === void 0 ? void 0 : _d.info) === null || _e === void 0 ? void 0 : _e.complete_ledgers) !== 'undefined') {
                                    socketMeta.ready = true;
                                    const ledgerString = String(((_g = (_f = response === null || response === void 0 ? void 0 : response.result) === null || _f === void 0 ? void 0 : _f.info) === null || _g === void 0 ? void 0 : _g.complete_ledgers) || '');
                                    const isFullHistory = ledgerString.split(',').length < 2 && ledgerString.split('-')[0] === '32570';
                                    if (!isFullHistory && !this.AllowNoFullHistory) {
                                        logInvalid('Closed connection to ', socket.url, 'incomplete history:', ledgerString);
                                        this.Endpoints[index] = '';
                                        yield socket.close();
                                    }
                                    else {
                                        logConnect('Ready:', socket.url);
                                    }
                                    resolve(socket);
                                }
                            }
                        }
                        catch (e) {
                            // Couldn't parse message from server as JSON
                        }
                    });
                });
            }
            return yield this.ReadyConnections[index];
        });
    }
    ConnectAndQuery(txHash) {
        return __asyncGenerator(this, arguments, function* ConnectAndQuery_1() {
            //           AsyncGenerator< next() result, return, next() param >
            let i = 0;
            while (i < this.Endpoints.length) {
                i++;
                yield yield __await(yield __await(new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                    let resolved = false;
                    let timeout;
                    const cancel = (resolveReason) => {
                        if (!resolved) {
                            clearTimeout(timeout);
                            resolve({ socket: false, result: false, resolveReason, url: this.Endpoints[i - 1] });
                            resolved = true;
                        }
                    };
                    timeout = setTimeout(() => {
                        cancel('timed out');
                    }, this.ConnectionAndQueryTimeoutMs);
                    const socket = yield this.Connect(i - 1);
                    if (socket.readyState !== socket.OPEN) {
                        cancel('resolved non-open');
                    }
                    const result = yield this.QueryConnection(socket, txHash);
                    // Allow the generator to yield
                    process.nextTick(() => {
                        this.EventBus.emit('result', { txHash, result, host: socket.url });
                    });
                    if (!resolved) {
                        clearTimeout(timeout);
                        resolve({ socket, result, resolveReason: 'results', url: this.Endpoints[i - 1] });
                    }
                }))));
            }
            // return 'Done :)'
        });
    }
    QueryConnection(connection, TxHash) {
        return __awaiter(this, void 0, void 0, function* () {
            this.CommandId++;
            const id = String(this.CommandId);
            // log({Get: TxHash, Id: id, Url: connection.url})
            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
                if (connection.readyState === connection.OPEN) {
                    connection.send(JSON.stringify({ id, command: 'tx', transaction: TxHash }));
                    const onTx = (r) => {
                        if (typeof r.id !== 'undefined') {
                            if (r.id === id) {
                                process.nextTick(() => {
                                    this.EventBus.removeListener('xrpljson', onTx);
                                });
                                return resolve(r);
                            }
                        }
                    };
                    this.EventBus.on('xrpljson', onTx);
                }
            }));
        });
    }
}
exports.TxData = TxData;
